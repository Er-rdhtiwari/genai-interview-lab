Nice, this is a *very* tight spec — let’s just do it end-to-end in one shot.

I’ll pick a **tiny but realistic** use case and wire **FastAPI + LLM client** on the app side and **Terraform + AWS (S3, RDS, Route 53)** on the infra side, with a dev-only footprint.

---

## 1. Problem Definition – Tiny, Realistic PoC

### Use Case – “LLM-Powered Release Note Helper for Infra Changes”

**Business context (3–5 lines)**
A small platform team is rolling out frequent infrastructure changes (Terraform modules, EKS tweaks, RDS parameter changes). They want a tiny internal tool where an engineer pastes a short description of a change (e.g. “switched RDS from t3.micro to t3.small for production”) and gets a concise, user-friendly release note sentence generated by an LLM. The team also wants to practice managing **Terraform-provisioned infra on AWS** (S3, RDS, Route 53) in a clean, modular way while keeping costs low.

### Functional Requirements (3–5 bullets)

* Provide **one HTTP endpoint**:
  `POST /api/v1/release-note` – takes a short free-text description of infra change and returns an LLM-generated release note line.
* Use **LLMClient abstraction**:

  * Real path: OpenAI API (if `OPENAI_API_KEY` present).
  * Fallback: deterministic mock response (works without any keys).
* Keep app data **in-memory only** for the PoC (no DB writes required).
* Expose **FastAPI OpenAPI docs** at `/docs`.

### Non-Functional Requirements (3–5 bullets)

* **Reliability:**

  * LLM errors must be caught; API returns meaningful HTTP 500 with safe message.
* **Security & Config:**

  * No secrets in code; all keys via env vars (`.env`), 12-factor style.
* **Observability:**

  * Basic structured logging using `logging` (no `print`).
* **Cost & Simplicity:**

  * Use minimal AWS footprint: one small RDS instance, one S3 bucket, one Route 53 hosted zone.
* **Deployability / IaC:**

  * Infra is fully defined as Terraform with **env-scoped state** and **modules**.

### Mapping PoC → Today’s Study Concepts

* **Terraform state & backends**

  * `terraform/envs/dev/backend.tf` uses a **local backend** for easy PoC; README explains how to upgrade to S3 + DynamoDB.
* **Modules & env separation**

  * `terraform/modules/{rds,s3_docs,dns}` with a **`dev` root module** under `envs/dev`.
* **AWS resources used**

  * **S3** bucket for “infra change logs/docs”.
  * **RDS** (Postgres) instance to illustrate DB infra (even though app uses in-memory data).
  * **Route 53** hosted zone and `A` record for `api.<root_domain>` pointing to `127.0.0.1` (designing DNS as code; in real world you’d point to ALB/EKS).
* **DNS / release patterns**

  * DNS is codified via the `dns` module. In README we outline how this would evolve to point to **ALB/EKS** and support **blue/green** using Route 53 weighted records.

---

## 2. Architecture Overview (HLD)

### 2.1 Application Architecture (FastAPI)

* Client: `curl` or any HTTP client calls `POST /api/v1/release-note`.
* `app/main.py`: FastAPI entrypoint, defines routes and wires services.
* `core/models.py`: Pydantic models for request/response and domain entities.
* `core/services.py`: Business logic to turn a change description into a structured LLM prompt and response.
* `core/llm_client.py`: LLM abstraction using OpenAI when available, with mock fallback.
* `config/settings.py`: Typed settings loaded from env vars using `pydantic-settings`.

### 2.2 Infrastructure Architecture (Terraform + AWS)

* Region: **`ap-south-1`** (Mumbai).
* Dev root module: `terraform/envs/dev/main.tf`.
* Modules:

  * `modules/s3_docs`: S3 bucket `dev-llm-docs-*` for infra docs or sample inputs.
  * `modules/rds`: RDS Postgres (`db.t3.micro`) in the default VPC for PoC.
  * `modules/dns`: Route 53 hosted zone for `example.com` (configurable) and an `A` record `api.example.com` → `127.0.0.1` (for now).
* State:

  * Local backend (`backend.tf`) for PoC; README explains S3+DynamoDB pattern.
* Flow (conceptual):

  * **Client** → `http://localhost:8000` where FastAPI runs.
  * Terraform-managed AWS side holds supporting infra (S3/RDS/DNS) to practice IaC patterns; in a real system you’d route **Route 53 → ALB → EKS → FastAPI**.

### 2.3 ASCII Diagram (App + Infra)

```text
+-----------+        +---------------------+        +------------------+
|  Client   |  --->  |  FastAPI (local)    |  --->  |  LLM Provider    |
| (curl)    |        |  /api/v1/release... |        | (OpenAI / mock)  |
+-----------+        +---------------------+        +------------------+

              Terraform-managed AWS (dev)
              +------------------------------+
              |  S3: dev-llm-docs-*          |
              |  RDS: dev-llm-db (Postgres)  |
              |  Route53: api.example.com    |
              +------------------------------+
```

**Where today’s concepts show up:**

* **Terraform modules & envs:** `envs/dev` root + `modules/rds`, `modules/s3_docs`, `modules/dns`.
* **State & backends:** `backend.tf` (local now; upgrade path to S3+DynamoDB).
* **DNS as code:** `api.<root_domain>` managed in Terraform; future step to point to ALB/EKS.

---

## 3. Repository Layout (App + Terraform)

### 3.1 Application Layout (Python)

```text
project_root/
  pyproject.toml          # Project metadata, deps, packaging (PEP 621)
  README.md               # Project overview, setup, cost & cleanup
  .env.example            # Sample env vars (LLM keys, app config)

  src/
    app/
      __init__.py         # Make app package importable
      main.py             # FastAPI entrypoint & routes

    core/
      __init__.py         # Core domain package
      models.py           # Pydantic models for requests/responses
      services.py         # Business logic (release note generation)
      llm_client.py       # LLMClient abstraction + mock fallback

    config/
      __init__.py         # Config package
      settings.py         # Typed settings via pydantic-settings

  tests/
    __init__.py           # Test package marker
    test_app.py           # Happy-path API test with TestClient
```

**One-line responsibilities**

* **`pyproject.toml`** – define dependencies (`fastapi`, `uvicorn`, `pydantic`, `openai`, `pytest`, etc) and package layout.
* **`README.md`** – how to run, how it maps to Terraform/IaC concepts, cost & cleanup.
* **`.env.example`** – sample env config; user copies to `.env`.
* **`app/main.py`** – HTTP API wiring only (no business logic).
* **`core/models.py`** – typed request/response/domain models.
* **`core/services.py`** – “release note from change description” logic.
* **`core/llm_client.py`** – provider-agnostic LLM wrapper with mock fallback.
* **`config/settings.py`** – centralized, typed configuration.
* **`tests/test_app.py`** – regression guard and usage example.

### 3.2 Terraform Layout (IaC)

```text
project_root/
  terraform/
    envs/
      dev/
        main.tf           # Wires modules for dev (RDS + S3 + DNS)
        variables.tf      # Input variables for dev env
        locals.tf         # Naming & common tags
        backend.tf        # State backend (local for PoC)
        outputs.tf        # Useful outputs (DB endpoint, bucket name, DNS name)

    modules/
      rds/
        main.tf           # RDS instance + subnet group + SG
        variables.tf
        outputs.tf

      s3_docs/
        main.tf           # S3 bucket for docs
        variables.tf
        outputs.tf

      dns/
        main.tf           # Route 53 hosted zone + api.<root_domain> A record
        variables.tf
        outputs.tf
```

**Which modules are actually used in this PoC?**

* **Used:** `modules/rds`, `modules/s3_docs`, `modules/dns`.
* **Not used:** `vpc`, `eks`, `acm_cert` – intentionally skipped to keep infra tiny; README explains how you’d extend.

---

## 4. Coding Conventions

I’ll follow your requested conventions:

* **Python:**

  * PEP 8, type hints, small focused functions.
  * `logging` module for logs.
  * Env-based config via `pydantic-settings`.
  * No secrets in code; everything via env or Terraform-managed secrets (for RDS password we use Terraform variables, not hardcoding).
* **Terraform:**

  * Formatted (`terraform fmt` style).
  * Small modules with clear inputs/outputs.
  * `locals` for names/tags.
  * No hard-coded secrets; DB password passed as variable at `apply` time.

---

## 5. Full Application Code (Copy-Paste Ready)

### 5.1 `pyproject.toml`

```toml
[project]
name = "terraform-genai-llm-poc"
version = "0.1.0"
description = "Tiny FastAPI + LLM PoC with Terraform-managed AWS infra"
readme = "README.md"
requires-python = ">=3.10"
license = { text = "MIT" }

authors = [
  { name = "Your Name", email = "you@example.com" }
]

dependencies = [
  "fastapi>=0.115.0",
  "uvicorn[standard]>=0.30.0",
  "pydantic>=2.7.0",
  "pydantic-settings>=2.8.0",
  "openai>=1.40.0",
  "httpx>=0.27.0",
]

[project.optional-dependencies]
dev = [
  "pytest>=8.2.0",
  "pytest-asyncio>=0.23.0",
]

[tool.setuptools]
package-dir = { "" = "src" }

[tool.setuptools.packages.find]
where = ["src"]

[tool.pytest.ini_options]
pythonpath = ["src"]
```

---

### 5.2 `.env.example`

```env
# LLM provider keys (only used if present)
OPENAI_API_KEY=sk-xxx
ANTHROPIC_API_KEY=sk-xxx
GOOGLE_API_KEY=AIzxxx
OLAMA_API_KEY=olama
HF_TOKEN=hf_xxx
GROK_MODEL=xai-xxx

# App settings
APP_ENV=dev
APP_NAME=terraform-genai-llm-poc
LOG_LEVEL=INFO
PORT=8000

# Optional database connection info (if you choose to use RDS in app later)
DB_HOST=localhost
DB_PORT=5432
DB_NAME=llm_poc
DB_USER=llm_user
DB_PASSWORD=replace-me
```

---

### 5.3 `src/config/settings.py`

```python
from functools import lru_cache
from typing import Optional

import logging
from pydantic import Field
from pydantic_settings import BaseSettings, SettingsConfigDict

logger = logging.getLogger(__name__)


class Settings(BaseSettings):
    """Application configuration loaded from environment variables."""

    app_env: str = Field(default="dev", alias="APP_ENV")
    app_name: str = Field(default="terraform-genai-llm-poc", alias="APP_NAME")
    log_level: str = Field(default="INFO", alias="LOG_LEVEL")
    port: int = Field(default=8000, alias="PORT")

    # LLM provider keys
    openai_api_key: Optional[str] = Field(default=None, alias="OPENAI_API_KEY")
    anthropic_api_key: Optional[str] = Field(default=None, alias="ANTHROPIC_API_KEY")
    google_api_key: Optional[str] = Field(default=None, alias="GOOGLE_API_KEY")
    olama_api_key: Optional[str] = Field(default=None, alias="OLAMA_API_KEY")
    hf_token: Optional[str] = Field(default=None, alias="HF_TOKEN")
    grok_model: Optional[str] = Field(default=None, alias="GROK_MODEL")

    # Optional DB configuration (not used directly in this PoC)
    db_host: Optional[str] = Field(default=None, alias="DB_HOST")
    db_port: Optional[int] = Field(default=None, alias="DB_PORT")
    db_name: Optional[str] = Field(default=None, alias="DB_NAME")
    db_user: Optional[str] = Field(default=None, alias="DB_USER")
    db_password: Optional[str] = Field(default=None, alias="DB_PASSWORD")

    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        case_sensitive=False,
    )


@lru_cache(maxsize=1)
def get_settings() -> Settings:
    """Return a cached Settings instance."""
    settings = Settings()
    logging.basicConfig(
        level=getattr(logging, settings.log_level.upper(), logging.INFO),
        format="%(asctime)s [%(levelname)s] %(name)s - %(message)s",
    )
    logger.info("Loaded settings for env=%s", settings.app_env)
    return settings
```

---

### 5.4 `src/core/llm_client.py`

```python
import logging
from typing import Optional

from openai import OpenAI, OpenAIError

from config.settings import Settings

logger = logging.getLogger(__name__)


class LLMClient:
    """
    Simple LLM client abstraction.

    - Uses OpenAI Chat Completions if OPENAI_API_KEY is configured.
    - Falls back to a deterministic mock response in all other cases.
    """

    def __init__(self, settings: Settings) -> None:
        self._settings = settings
        self._client: Optional[OpenAI] = None

        if settings.openai_api_key:
            logger.info("Initializing OpenAI client for LLMClient.")
            self._client = OpenAI(api_key=settings.openai_api_key)
        else:
            logger.info(
                "No OPENAI_API_KEY found. LLMClient will operate in MOCK mode."
            )

    def generate_text(self, prompt: str) -> str:
        """
        Generate a short text completion for the given prompt.

        If OpenAI is not configured or a call fails, returns a deterministic
        MOCK_LLM_RESPONSE string for reliability.
        """
        if not self._client:
            logger.info("Using mock LLM response (no provider configured).")
            return f"MOCK_LLM_RESPONSE for: {prompt}"

        try:
            logger.info("Calling OpenAI chat completions for prompt.")
            response = self._client.chat.completions.create(
                model="gpt-4o-mini",
                messages=[
                    {
                        "role": "system",
                        "content": (
                            "You are a concise release-note helper. "
                            "You produce one short sentence suitable for "
                            "a changelog visible to engineers."
                        ),
                    },
                    {"role": "user", "content": prompt},
                ],
                max_tokens=80,
                temperature=0.3,
            )
            choice = response.choices[0]
            text = choice.message.content or ""
            logger.info("Received LLM response with %d tokens.", len(text))
            return text.strip()
        except OpenAIError as exc:
            logger.error("OpenAI call failed: %s. Falling back to mock.", exc)
            return f"MOCK_LLM_RESPONSE for: {prompt}"
        except Exception as exc:  # noqa: BLE001
            logger.error("Unexpected error in LLMClient: %s", exc)
            return f"MOCK_LLM_RESPONSE for: {prompt}"
```

---

### 5.5 `src/core/models.py`

```python
from pydantic import BaseModel, Field


class ReleaseNoteRequest(BaseModel):
    """Incoming payload describing an infrastructure change."""

    change_summary: str = Field(
        ...,
        description="Short free-text description of the infrastructure change.",
        min_length=5,
        max_length=1000,
    )
    tone: str = Field(
        default="neutral",
        description="Optional tone hint such as 'neutral', 'formal', or 'casual'.",
    )


class ReleaseNoteResponse(BaseModel):
    """Response containing a generated release note line."""

    release_note: str = Field(
        ...,
        description="A concise release-note sentence.",
    )
    provider: str = Field(
        ...,
        description="LLM provider used (e.g., 'openai' or 'mock').",
    )
```

---

### 5.6 `src/core/services.py`

```python
import logging

from .llm_client import LLMClient
from .models import ReleaseNoteRequest, ReleaseNoteResponse

logger = logging.getLogger(__name__)


def build_prompt(payload: ReleaseNoteRequest) -> str:
    """
    Construct a prompt for the LLM based on the incoming payload.

    This keeps prompt-building logic separate and easy to test.
    """
    tone_instruction = (
        "Use a neutral, professional tone."
        if payload.tone.lower() == "neutral"
        else f"Use a {payload.tone.lower()} tone."
    )

    prompt = (
        "You are helping a platform team write concise release notes for "
        "infrastructure changes (Terraform, AWS, Kubernetes, databases).\n\n"
        f"Change description:\n{payload.change_summary}\n\n"
        "Return exactly one sentence suitable for a technical changelog.\n"
        f"{tone_instruction}"
    )
    logger.debug("Built LLM prompt for release note.")
    return prompt


def generate_release_note(
    payload: ReleaseNoteRequest,
    llm_client: LLMClient,
    provider_name: str,
) -> ReleaseNoteResponse:
    """
    Generate a release note sentence using the given LLM client.
    """
    prompt = build_prompt(payload)
    logger.info("Generating release note using provider=%s.", provider_name)
    text = llm_client.generate_text(prompt=prompt)

    # A tiny safety/trimming step
    release_note = text.replace("\n", " ").strip()

    if not release_note.endswith("."):
        release_note += "."

    return ReleaseNoteResponse(
        release_note=release_note,
        provider=provider_name,
    )
```

---

### 5.7 `src/app/main.py`

```python
"""
Run locally:

    uvicorn app.main:app --reload
"""

import logging
from typing import Annotated

from fastapi import Depends, FastAPI, HTTPException, status

from config.settings import Settings, get_settings
from core.llm_client import LLMClient
from core.models import ReleaseNoteRequest, ReleaseNoteResponse
from core.services import generate_release_note

logger = logging.getLogger(__name__)


def get_llm_client(settings: Settings = Depends(get_settings)) -> LLMClient:
    """FastAPI dependency that returns a configured LLMClient instance."""
    return LLMClient(settings=settings)


def get_provider_name(settings: Settings = Depends(get_settings)) -> str:
    """Derive provider name based on which key is configured."""
    if settings.openai_api_key:
        return "openai"
    return "mock"


SettingsDep = Annotated[Settings, Depends(get_settings)]
LLMClientDep = Annotated[LLMClient, Depends(get_llm_client)]
ProviderDep = Annotated[str, Depends(get_provider_name)]

app = FastAPI(
    title="Terraform + GenAI Release Note Helper",
    version="0.1.0",
    description=(
        "Tiny FastAPI service that turns infra change descriptions into "
        "short release-note sentences using an LLM (or a mock)."
    ),
)


@app.get("/health", tags=["system"])
def health() -> dict[str, str]:
    """Simple health check endpoint."""
    return {"status": "ok"}


@app.post(
    "/api/v1/release-note",
    response_model=ReleaseNoteResponse,
    tags=["release-notes"],
)
def create_release_note(
    payload: ReleaseNoteRequest,
    llm_client: LLMClientDep,
    provider_name: ProviderDep,
) -> ReleaseNoteResponse:
    """
    Generate a release note sentence for the given infrastructure change summary.
    """
    try:
        return generate_release_note(payload, llm_client, provider_name)
    except Exception as exc:  # noqa: BLE001
        logger.error("Failed to generate release note: %s", exc)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to generate release note.",
        ) from exc
```

---

### 5.8 `tests/test_app.py`

```python
from fastapi.testclient import TestClient

from app.main import app

client = TestClient(app)


def test_health_endpoint() -> None:
    """Verify the health endpoint returns status ok."""
    response = client.get("/health")
    assert response.status_code == 200
    assert response.json() == {"status": "ok"}


def test_release_note_mock_mode() -> None:
    """
    When no real LLM key is configured, the service should still work
    and return a deterministic MOCK_LLM_RESPONSE.
    """
    payload = {
        "change_summary": "Upgraded RDS instance from t3.micro to t3.small for production.",
        "tone": "neutral",
    }
    response = client.post("/api/v1/release-note", json=payload)
    assert response.status_code == 200

    body = response.json()
    assert "release_note" in body
    assert "provider" in body
    assert body["provider"] in ("mock", "openai")
    assert isinstance(body["release_note"], str)
    assert len(body["release_note"]) > 0
```

---

## 6. Terraform Code (Minimal but Real)

> **Note:** For the PoC, the backend is **local** for simplicity. In real infra you’d replace it with S3 + DynamoDB as per your Day-31 notes.

### 6.1 `terraform/envs/dev/backend.tf`

```hcl
terraform {
  backend "local" {
    path = "terraform.tfstate"
  }
}
```

---

### 6.2 `terraform/envs/dev/variables.tf`

```hcl
variable "env" {
  type        = string
  description = "Deployment environment (e.g. dev, stage, prod)."
  default     = "dev"
}

variable "aws_region" {
  type        = string
  description = "AWS region to deploy into."
  default     = "ap-south-1"
}

variable "db_name" {
  type        = string
  description = "Logical database name for the RDS instance."
  default     = "llm_poc"
}

variable "db_username" {
  type        = string
  description = "Master username for the RDS instance."
  default     = "llm_user"
}

variable "db_password" {
  type        = string
  description = "Master password for the RDS instance (pass via TF_VAR_db_password)."
  sensitive   = true
}

variable "root_domain" {
  type        = string
  description = "Root domain for the hosted zone (e.g. example.com)."
  default     = "example.com"
}

variable "api_subdomain" {
  type        = string
  description = "Subdomain used for the API (e.g. api)."
  default     = "api"
}
```

---

### 6.3 `terraform/envs/dev/locals.tf`

```hcl
locals {
  name_prefix = "llm-${var.env}"

  common_tags = {
    app         = "terraform-genai-llm-poc"
    environment = var.env
    owner       = "platform-team"
  }
}
```

---

### 6.4 `terraform/envs/dev/main.tf`

```hcl
terraform {
  required_version = ">= 1.6.0"

  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
}

provider "aws" {
  region = var.aws_region
}

module "s3_docs" {
  source = "../../modules/s3_docs"

  env           = var.env
  bucket_prefix = "${local.name_prefix}-docs"
  tags          = local.common_tags
}

module "rds" {
  source = "../../modules/rds"

  env               = var.env
  db_name           = var.db_name
  db_username       = var.db_username
  db_password       = var.db_password
  instance_class    = "db.t3.micro"
  allocated_storage = 20

  tags = local.common_tags
}

module "dns" {
  source = "../../modules/dns"

  env           = var.env
  root_domain   = var.root_domain
  api_subdomain = var.api_subdomain

  tags = local.common_tags
}
```

---

### 6.5 `terraform/envs/dev/outputs.tf`

```hcl
output "docs_bucket_name" {
  description = "Name of the S3 bucket used for docs."
  value       = module.s3_docs.bucket_name
}

output "db_endpoint" {
  description = "Endpoint of the RDS instance."
  value       = module.rds.db_endpoint
}

output "db_name" {
  description = "Database name configured on the RDS instance."
  value       = module.rds.db_name
}

output "api_fqdn" {
  description = "Fully-qualified domain name for the API (DNS record)."
  value       = module.dns.api_fqdn
}
```

---

### 6.6 `terraform/modules/s3_docs/variables.tf`

```hcl
variable "env" {
  type        = string
  description = "Environment suffix for naming."
}

variable "bucket_prefix" {
  type        = string
  description = "Prefix for the S3 bucket name."
}

variable "tags" {
  type        = map(string)
  description = "Common tags to apply to S3 resources."
  default     = {}
}
```

---

### 6.7 `terraform/modules/s3_docs/main.tf`

```hcl
resource "aws_s3_bucket" "docs" {
  bucket = "${var.bucket_prefix}-${var.env}"

  tags = merge(
    var.tags,
    {
      Name = "${var.bucket_prefix}-${var.env}"
    }
  )
}

resource "aws_s3_bucket_versioning" "docs" {
  bucket = aws_s3_bucket.docs.id

  versioning_configuration {
    status = "Enabled"
  }
}
```

---

### 6.8 `terraform/modules/s3_docs/outputs.tf`

```hcl
output "bucket_name" {
  description = "Name of the S3 docs bucket."
  value       = aws_s3_bucket.docs.bucket
}
```

---

### 6.9 `terraform/modules/rds/variables.tf`

```hcl
variable "env" {
  type        = string
  description = "Environment suffix for naming."
}

variable "db_name" {
  type        = string
  description = "Logical database name."
}

variable "db_username" {
  type        = string
  description = "Master username."
}

variable "db_password" {
  type        = string
  description = "Master password (sensitive)."
  sensitive   = true
}

variable "allocated_storage" {
  type        = number
  description = "RDS allocated storage in GB."
  default     = 20
}

variable "instance_class" {
  type        = string
  description = "RDS instance class."
  default     = "db.t3.micro"
}

variable "tags" {
  type        = map(string)
  description = "Common tags to apply to RDS resources."
  default     = {}
}

variable "db_access_cidr" {
  type        = string
  description = "CIDR block allowed to connect to RDS (PoC only)."
  default     = "0.0.0.0/0"
}
```

---

### 6.10 `terraform/modules/rds/main.tf`

```hcl
data "aws_vpc" "default" {
  default = true
}

data "aws_subnets" "default" {
  filter {
    name   = "vpc-id"
    values = [data.aws_vpc.default.id]
  }
}

resource "aws_db_subnet_group" "this" {
  name       = "${var.env}-llm-db-subnets"
  subnet_ids = data.aws_subnets.default.ids

  tags = merge(
    var.tags,
    {
      Name = "${var.env}-llm-db-subnets"
    }
  )
}

resource "aws_security_group" "db" {
  name        = "${var.env}-llm-db-sg"
  description = "Security group for LLM PoC RDS instance (PoC ONLY)."
  vpc_id      = data.aws_vpc.default.id

  ingress {
    from_port   = 5432
    to_port     = 5432
    protocol    = "tcp"
    cidr_blocks = [var.db_access_cidr]
  }

  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
  }

  tags = merge(
    var.tags,
    {
      Name = "${var.env}-llm-db-sg"
    }
  )
}

resource "aws_db_instance" "this" {
  identifier = "${var.env}-llm-db"

  engine               = "postgres"
  engine_version       = "15.5"
  instance_class       = var.instance_class
  allocated_storage    = var.allocated_storage
  db_name              = var.db_name
  username             = var.db_username
  password             = var.db_password
  db_subnet_group_name = aws_db_subnet_group.this.name

  skip_final_snapshot = true
  publicly_accessible = true

  vpc_security_group_ids = [aws_security_group.db.id]

  tags = merge(
    var.tags,
    {
      Name = "${var.env}-llm-db"
    }
  )
}
```

---

### 6.11 `terraform/modules/rds/outputs.tf`

```hcl
output "db_endpoint" {
  description = "Endpoint of the RDS instance."
  value       = aws_db_instance.this.endpoint
}

output "db_name" {
  description = "Database name configured on the RDS instance."
  value       = aws_db_instance.this.db_name
}
```

---

### 6.12 `terraform/modules/dns/variables.tf`

```hcl
variable "env" {
  type        = string
  description = "Environment suffix for tagging."
}

variable "root_domain" {
  type        = string
  description = "Root domain for the hosted zone (e.g. example.com)."
}

variable "api_subdomain" {
  type        = string
  description = "Subdomain for the API (e.g. api)."
  default     = "api"
}

variable "tags" {
  type        = map(string)
  description = "Common tags to apply to DNS resources."
  default     = {}
}
```

---

### 6.13 `terraform/modules/dns/main.tf`

```hcl
resource "aws_route53_zone" "root" {
  name = var.root_domain

  tags = merge(
    var.tags,
    {
      Name = "${var.env}-llm-zone"
    }
  )
}

resource "aws_route53_record" "api" {
  zone_id = aws_route53_zone.root.zone_id
  name    = "${var.api_subdomain}.${var.root_domain}"
  type    = "A"
  ttl     = 300

  # For this PoC, point to localhost so the name conceptually maps
  # to your local FastAPI instance.
  records = ["127.0.0.1"]
}
```

---

### 6.14 `terraform/modules/dns/outputs.tf`

```hcl
output "api_fqdn" {
  description = "Fully-qualified domain name for the API."
  value       = aws_route53_record.api.fqdn
}
```

---

## 7. Ready-to-Use Testing Commands

### 7.1 Run the App Locally

```bash
python -m venv .venv
source .venv/bin/activate  # Windows: .venv\Scripts\activate
pip install .

cp .env.example .env       # optional: set OPENAI_API_KEY for real calls

uvicorn app.main:app --reload
```

Interactive docs: **[http://localhost:8000/docs](http://localhost:8000/docs)**

### 7.2 `curl` Examples

**1. Health check**

```bash
curl http://localhost:8000/health
```

**2. Generate release note (mock mode or OpenAI if key present)**

```bash
curl -X POST http://localhost:8000/api/v1/release-note \
  -H "Content-Type: application/json" \
  -d '{
        "change_summary": "Switched RDS dev instance from db.t3.micro to db.t3.small to handle higher test load.",
        "tone": "neutral"
      }'
```

**3. Casual tone**

```bash
curl -X POST http://localhost:8000/api/v1/release-note \
  -H "Content-Type: application/json" \
  -d '{
        "change_summary": "Enabled S3 versioning for all Terraform state backup buckets.",
        "tone": "casual"
      }'
```

### 7.3 Terraform Commands (Dev Env)

```bash
cd terraform/envs/dev

# First-time setup
terraform init

# See what will be created
terraform plan \
  -var="db_password=replace-with-strong-password"

# Apply the changes
terraform apply \
  -var="db_password=replace-with-strong-password"
```

---

## 8. System Design Evolution, Cost & Cost Control

### 8.1 How This Would Evolve in a Real System (8–12 bullets)

* Add **authn/authz** (e.g., JWT, SSO) to restrict who can generate release notes.
* Replace in-memory storage with **RDS Postgres** (or another DB) storing audit logs, change metadata, and generated notes.
* Use **EKS or ECS** to run the FastAPI service behind an **ALB**.
* Point **Route 53** `api.<root_domain>` to ALB instead of `127.0.0.1`.
* Add **ACM** certificates and attach them to ALB → full HTTPS.
* Implement **blue/green** or **canary** releases using Route 53 weighted records and dedicated ALBs or namespaces.
* Add **structured logging + metrics** (CloudWatch, Prometheus) and dashboards for usage and error tracking.
* Introduce **background jobs/queues** (e.g., SQS) if generating long or batch notes.
* Integrate **caching** (ElastiCache/Redis) for frequent prompts.
* Add **multi-region** redundancy if needed for very high availability.
* Centralize **secrets** in Secrets Manager/SSM, not env vars, and wire into pods/containers via IRSA or similar.

### 8.2 Approximate AWS Cost (USD + INR)

Assumptions:

* Region: `ap-south-1`.
* **RDS db.t3.micro**: about **$0.018/hour** on demand (2 vCPUs, 1GB RAM). ([Vantage][1])
* **S3 Standard storage**: about **$0.023–$0.0265/GB/month** for first 50 TB. ([Amazon Web Services, Inc.][2])
* **Route 53 hosted zone**: **$0.50/month** for first 25 zones. ([Amazon Web Services, Inc.][3])
* USD→INR ≈ **₹90 per USD** as of Dec 2025. ([Wise][4])

Estimates:

* **RDS (db.t3.micro)**

  * Monthly: `0.018 * 24 * 30 ≈ $13.0` → ≈ **₹1,170–1,200/month**.
* **S3 (5 GB for docs)**

  * `5 * 0.023 ≈ $0.12` → ≈ **₹10–11/month**.
* **Route 53 hosted zone (1 zone)**

  * `≈ $0.50/month` → ≈ **₹45/month**.
* **Total PoC ballpark:**

  * ≈ **$13.6/month** → around **₹1,220/month** if resources run 24x7.

**Daily cost ballpark:**
~`$13.6 / 30 ≈ $0.45/day` → roughly **₹40/day**.

> RDS dominates cost; S3 + Route 53 are tiny in comparison.

### 8.3 Cost-Control Practices (3–5 bullets)

* **Use smallest instance classes** (e.g., `db.t3.micro`) and minimal storage in dev.
* **Turn off/destroy infra when idle**, especially RDS and any future EKS/ALB resources (`terraform destroy` at the end of each experiment).
* Prefer **local / mock LLMs** for development and tests to avoid API billing; use real LLMs only in integration/production.
* **Set TTLs and budgets** in AWS (billing alerts) so you notice runaway costs early.
* For future EKS/ALB usage, share **multi-tenant clusters** and ALBs where appropriate rather than spinning one per microservice.

---

## 9. AWS Cleanup & Console Verification

### 9.1 Terraform Cleanup Steps

From the project root:

```bash
cd terraform/envs/dev

# Destroy all resources managed by this state
terraform destroy \
  -var="db_password=replace-with-strong-password"
```

This should delete:

* The dev RDS instance and its subnet group + SG.
* The S3 docs bucket.
* The Route 53 hosted zone and associated records.

**Important notes:**

* `terraform destroy` only affects resources tracked in this **dev** state.
* If you create additional resources manually in the AWS console (or via other tools), you must clean those up separately.
* For safety, run `terraform plan` afterward – it should show **no changes** expected.

### 9.2 AWS Console Verification Checklist

After `terraform apply` and again after `terraform destroy`, check:

* **RDS**:

  * Console → RDS → Databases.
  * Look for an instance named like `dev-llm-db`.
  * Confirm it appears after apply, and is **gone** after destroy.
* **S3**:

  * Console → S3.
  * Look for bucket named similar to `${bucket_prefix}-${env}` (e.g., `llm-dev-docs-dev`).
  * Confirm it exists after apply and is deleted after destroy.
* **Route 53**:

  * Console → Route 53 → Hosted zones.
  * Look for hosted zone for `example.com` (or your configured `root_domain`).
  * Check that an `A` record for `api.<root_domain>` exists. Confirm both hosted zone and records are removed after destroy.
* **VPC / Security Groups**:

  * Console → VPC → Security Groups.
  * Search for a group like `dev-llm-db-sg`. Confirm it is created and later removed.
* **Billing** (optional but wise):

  * Console → Billing / Cost Explorer.
  * Filter by service (RDS, S3, Route 53) and verify that costs reflect your experimental usage and that resources are gone after cleanup.

Always double-check for any **orphan resources** (especially RDS and Route 53 hosted zones) to avoid surprise billing.

---

## 10. `README.md`

````markdown
# Terraform + GenAI Release Note Helper (PoC)

## Overview

This PoC is a tiny, end-to-end example that combines:

- A **FastAPI** service that turns infrastructure change descriptions into one-line release notes using an LLM (or a mock).
- A small **Terraform** stack that provisions supporting AWS resources:
  - **RDS** (Postgres, db.t3.micro),
  - **S3** bucket for docs,
  - **Route 53** hosted zone and an `api.<root_domain>` record.

The goal is to practice **Terraform / IaC patterns for AWS** in a GenAI context while keeping the system small and cost-aware.

## How this uses today's study notes

- **IaC fundamentals & Terraform basics**  
  - Root module under `terraform/envs/dev` and modules under `terraform/modules/*`.
  - `terraform init`, `plan`, `apply`, `destroy` workflow with clear variables.

- **State & backends**  
  - `backend.tf` uses a **local backend** for simplicity.  
  - Easily upgradable to **S3 + DynamoDB** remote state as recommended in production.

- **Modules & structure**  
  - `modules/rds` for RDS, `modules/s3_docs` for S3 bucket, `modules/dns` for Route 53.
  - `locals.tf` centralizes naming and tagging.

- **Environments**  
  - `envs/dev` is a dedicated root module; stage/prod can be added as separate folders with their own backends and tfvars.

- **GenAI focus**  
  - `core/llm_client.py` encapsulates LLM provider logic with a clean fallback.
  - `core/services.py` shows how a small GenAI feature can be layered into a production-style app layout.

- **DNS / RELEASE-FOCUSED**  
  - `modules/dns` manages a hosted zone and `api.<root_domain>` record.  
  - README describes how to evolve this to ALB/EKS + blue/green via Route 53 weighted records.

## Tech Stack

- **Backend**: Python 3.10+, FastAPI, Pydantic v2, pydantic-settings.
- **LLM client**: OpenAI Chat Completions (optional), with mock fallback.
- **Infra**: Terraform 1.6+, AWS (RDS, S3, Route 53).
- **Testing**: pytest, FastAPI TestClient.

## Setup

### 1. Python environment

```bash
python -m venv .venv
source .venv/bin/activate         # Windows: .venv\Scripts\activate
pip install .
````

Configure environment (optional, for real LLM calls):

```bash
cp .env.example .env
# Edit .env and set OPENAI_API_KEY or other provider keys if desired
```

### 2. Terraform (dev environment)

> ⚠️ This PoC creates **real AWS resources** (RDS, S3, Route 53 hosted zone).
> Make sure you are using the right AWS account and are comfortable with the small monthly cost.

```bash
cd terraform/envs/dev

terraform init

terraform plan \
  -var="db_password=replace-with-strong-password"

terraform apply \
  -var="db_password=replace-with-strong-password"
```

After `apply`, Terraform will output:

* `docs_bucket_name` – S3 bucket holding docs.
* `db_endpoint` and `db_name` – RDS connection info.
* `api_fqdn` – DNS name for the API (currently pointing to 127.0.0.1).

## Run

From the project root:

```bash
source .venv/bin/activate
uvicorn app.main:app --reload
```

FastAPI will listen on `http://127.0.0.1:8000` by default.

Interactive API docs: **[http://localhost:8000/docs](http://localhost:8000/docs)**

## Quick Test

Health check:

```bash
curl http://localhost:8000/health
```

Generate a release note:

```bash
curl -X POST http://localhost:8000/api/v1/release-note \
  -H "Content-Type: application/json" \
  -d '{
        "change_summary": "Enabled versioning on all S3 buckets that hold Terraform state.",
        "tone": "neutral"
      }'
```

You should see a JSON response containing a `release_note` string and the `provider` used (`mock` or `openai`).

## AWS Cost & Cleanup

### Cost (rough estimate)

Assuming:

* **RDS db.t3.micro** running 24x7 for a month,
* ~5 GB in S3,
* 1 Route 53 hosted zone,

you should expect roughly:

* RDS: ≈ **$13.0/month** (≈ ₹1,170–1,200).
* S3: ≈ **$0.12/month** (≈ ₹10–11).
* Route 53: ≈ **$0.50/month** (≈ ₹45).

Total PoC ballpark: ≈ **$13.6/month** (~₹1,220/month).
For short experiments, this will be proportionally lower.

### Cleanup (very important)

From `terraform/envs/dev`:

```bash
terraform destroy \
  -var="db_password=replace-with-strong-password"
```

Then verify in the AWS console:

* **RDS**: `dev-llm-db` instance removed.
* **S3**: docs bucket deleted.
* **Route 53**: hosted zone and `api.<root_domain>` record removed.
* **Security Groups/Subnet Groups**: no `dev-llm-*` resources left.

Delete any remaining orphans manually to avoid unnecessary charges.

## Next Steps / Extensions

* Attach FastAPI to **EKS/ECS + ALB**, and point Route 53 records to the ALB.
* Introduce **ACM certificates** + HTTPS and experiment with DNS validation in Terraform.
* Store generated release notes and metadata in **RDS** and visualize them in a small UI.
* Add **blue/green** releases using Route 53 weighted records and separate stacks.
* Integrate **observability** (CloudWatch, Prometheus/Grafana) and CI/CD for Terraform and app.

```

---

If you’d like, next iteration we can **swap local FastAPI for EKS + ALB** and wire Route 53 → ALB → EKS → FastAPI to fully exercise the Kubernetes/TLS part, but this PoC keeps the infra surface small while still grounding everything in today’s Terraform/IaC concepts.
::contentReference[oaicite:4]{index=4}
```

[1]: https://instances.vantage.sh/aws/rds/db.t3.micro?utm_source=chatgpt.com "db.t3.micro pricing and specs - Vantage"
[2]: https://aws.amazon.com/s3/pricing/?utm_source=chatgpt.com "S3 Pricing"
[3]: https://aws.amazon.com/route53/pricing/?utm_source=chatgpt.com "Amazon Route 53 pricing"
[4]: https://wise.com/in/currency-converter/usd-to-inr-rate?amount=1&utm_source=chatgpt.com "1 US dollar to Indian rupees Exchange Rate. Convert USD ..."
